"use strict";
var c = console;

angular.module('Relate', []);

angular.module('Relate').factory('BaseContainer', ["$q", function($q) {
  /*
  A collection has an internal index of the objects in the database.
  What it uses as keys and values is up to the derived class.
  */
  var BaseContainer = function()    {var self = this;
    self.__index = null;
    self.__db = null;
    self.dbDocumentType = null;
  };
  var def = BaseContainer.prototype;
  
  def.postInitialLoading = function() {
    //override if container needs to do any post loading operations
  };
  
  def.__postAndLoad = function(document)  {var self = this;
    var defered = $q.defer();
    document.type = self.dbDocumentType;
    self.__db.post(document).then( function (result) {
      if (result.ok) {
        self.__db.get(result.id).then( function (docFromDb) {
          defered.resolve(self.loadDocumentFromDb(docFromDb));
        });
      } else {
        console.log(result);
        throw "Error fetching data";
      }
    });
    return defered.promise;
  };
  
  return BaseContainer;
}]);

angular.module('Relate').factory('Collection', ["util", "$q", "BaseContainer", function(util, $q, BaseContainer) {

  var Collection = function(db, singleItemName, fieldNames, options)    {var self = this;
    var options = options || {};
    self.itemName = singleItemName;
    self.name = singleItemName; //This is how a relationship references collection
    self.plural = options.plural || singleItemName + 's'
    self.dbDocumentType = options.dbDocumentType || singleItemName;
    self.__db = db;
    self.__constructorFunction = options.constructorFunction || function(){};
    self.__items = {};
    self.__relationships = [];
    self.__fieldNames = fieldNames.slice();
    self.__fullFieldNames = fieldNames.slice();
    self.__fullFieldNames.push('_id');
    self.__fullFieldNames.push('_rev');
  };
  util.inheritPrototype(Collection, BaseContainer);
  var def = Collection.prototype;

  def.registerRelationship = function(relationship, fieldName)    {var self = this;
    self.__relationships.push(relationship);
    if (fieldName) {
      self.__fullFieldNames.push(fieldName);
    }
  };

  def.loadDocumentFromDb = function(doc)    {var self = this;
    var item = new self.__constructorFunction();
    util.copyFields(doc, item, self.__fullFieldNames);
    item.type = self.itemName;
    self.__items[doc._id] = item;
    return item;
  };

  def.getAccessFunctionDefinitions = function()    {var self = this;
    var capitalize = util.capitalizeFirstLetter,
        buildFunc = util.createAccessFunctionDefinition,
        single = capitalize(self.itemName),
        plural = capitalize(self.plural);
    return [
      buildFunc('new' + single, self.newItem, true),
      buildFunc('get' + single, self.getItem, false),
      buildFunc('find' + plural, self.findItems, false),
      buildFunc('all' + plural, self.allItems, false),
    ]
  };

  def.getItem = function(id)    {var self = this;
    return self.__items[id];
  };

  def.allItems = function()    {var self = this;
    return Object.keys(self.__items).map(function(i){
      return self.__items[i];
    });
  };

  def.findItems = function(query)    {var self = this;
    /*
    query can be:
      a function returning true or false
      an object like {name: 'deirdre'} -- which returns items whose properties match.
      an empty object {} -- which returns all items.
    TODO: what about parent properties?
    */
    var test;
    if (typeof query === 'function') {
      test = query;
    } else if (typeof query === 'object') {
      test = function(item) {
        for (prop in query) {
          if (item[prop] !== query[prop]) {
            return false;
          }
        }
        return true;
      }
    } else {
      throw 'Invalid argument for "find", must be an object or a function.';
    }
    return util.filterIndex(self.__items, test);
  };

  def.newItem = function(data)    {var self = this;
    if(data === undefined) {
      throw 'newItem expects an object as its first argument.'
    }
    var deferred = $q.defer();
    var doc = {};
    util.copyFields(data, doc, self.__fieldNames);
    self.__postAndLoad(doc).then(function (newItem) {
      //TODO: link relationships...
      deferred.resolve(newItem);
    });
    return deferred.promise;
  };

  def.saveItem = function(item)    {var self = this;
    var deferred = $q.defer();
    var doc = {};
    util.copyFields(item, doc, self.__fullFieldNames);
    self.__db.put(doc).then(function (result) {
      item._rev = result.rev;
      deferred.resolve(item._rev);
    });
    return deferred.promise;
  };

  def.deleteItem = function(item)    {var self = this;
    var childDeletions = self.__relationships.map(function(relationship) {
      return relationship.respondToItemDeleted(item, self);
    });
    return $q.all(childDeletions).then(function() {
      self.__db.remove(item).then(function (result) {
        delete self.__items[item._id];
      }, util.promiseFailed);
    }, util.promiseFailed);
  };

  return Collection;
}]);


angular.module('Relate').factory('ItemChildrenRegister', ["util", "$q", "BaseContainer", function(util, $q, BaseContainer) {

  var ItemChildrenRegister = function(db, parentCollection, childCollection, options)    {var self = this;
    var options = options || {};
    var childAlias = options.childAlias || childCollection.itemName;
    var parentAlias = options.parentAlias || parentCollection.itemName;
    self.dbDocumentType = 'lnk_child_' + childAlias + 's_of_' + parentAlias;
    self.__db = db;
    self.__parentCollection = parentCollection;
    self.__childCollection = childCollection;
    self.__cascadeDelete = options.cascadeDelete || false;
    self.__index = {};//format {parentId: {doc: Object, liveChildren: []}
    self.__reverseIndex = {};//format {childId: parentId}
  };
  util.inheritPrototype(ItemChildrenRegister, BaseContainer);
  var def = ItemChildrenRegister.prototype;
  
  def.loadDocumentFromDb = function(doc)     {var self = this;
    var parentId = doc.parentId;
    if (self.__index[parentId]) {
      throw "Found duplicate item children link in database."
    }
    var newEntry = {doc: doc};
    self.__index[parentId] = newEntry;
    angular.forEach(doc.childrenIds, function (childId) {
      self.__reverseIndex[childId] = parentId;
    });
    return newEntry;
  };

  def.getChildren = function(parentItem)    {var self = this;
    var indexEntry = self.__index[parentItem._id];
    if (indexEntry) {
      self.__ensureIndexEntryHasLiveChildren(indexEntry);
      return indexEntry.liveChildren;
    } else {
      return [];
    }
  };

  def.linkChildToParent = function(parentItem, childItem)    {var self = this;
    var deferred = $q.defer(),
        parentItemId = parentItem? parentItem._id : null,
        indexEntry = self.__index[parentItemId],
        innerPromise;
    //Note: parentItemId and indexEntry could rightfully be null/undefined.
    self.__unlinkChildFromPreviousParent(childItem).then(function() {
      self.__reverseIndex[childItem._id] = parentItemId;
      if (indexEntry) {
        innerPromise = self.__addChildToIndexEntry(indexEntry, childItem);
      } else {
        innerPromise = self.__postAndLoad({
          parentId: parentItem._id,
          childrenIds: [childItem._id]
        });
      }
      innerPromise.then(function () {
        deferred.resolve();
      });
    });
    return deferred.promise;
  };

  def.respondToParentDeleted = function(parentItem)    {var self = this;
    var deferred = $q.defer();
    indexEntry = self.__index[parentItem._id];
    if (indexEntry) {
      if (self.__cascadeDelete && indexEntry.doc.childrenIds.length > 0) {
        debug(indexEntry);
        throw 'Cannot delete parent object as it still has children';
      } else {
        self.__db.remove(indexEntry.doc).then(function() {
          delete self.__index[parentItem._id];
          deferred.resolve();
        });
      }
    }
    return deferred.promise;
  };

  def.respondToChildDeleted = function(childItem)    {var self = this;
    return self.__unlinkChildFromPreviousParent(childItem);
  };

  def.__addChildToIndexEntry = function(indexEntry, childItem)    {var self = this;
    var deferred = $q.defer();
    self.__ensureIndexEntryHasLiveChildren(indexEntry);
    if (util.arrayContains(indexEntry.doc.childrenIds, childItem._id)) {
      deferred.resolve();
    } else {
      indexEntry.doc.childrenIds.push(childItem.Id);
      self.__db.put(indexEntry.doc).then(function() {
        indexEntry.liveChildren.push(childItem),
        deferred.resolve();
      });
    }
    return deferred.promise;
  };
  
  def.__unlinkChildFromPreviousParent = function(childItem)    {var self = this;
    var deferred = $q.defer();
    var oldParentId = self.__reverseIndex[childItem._id];
    if (oldParentId) {
      var indexEntry = self.__index[oldParentId];
      util.removeFromArray(indexEntry.doc.childrenIds, childItem._id);
      self.__reverseIndex[childItem._id] = null;
      self.__db.put(indexEntry.doc).then(function() {
        self.__ensureIndexEntryHasLiveChildren(indexEntry);
        util.removeFromArray(indexEntry.liveChildren, childItem);
        deferred.resolve();
      });
    } else {
      deferred.resolve();
    }
    return deferred.promise;
  };

  def.__ensureIndexEntryHasLiveChildren = function(indexEntry)    {var self = this;
    var liveChildren = indexEntry.liveChildren;
    if (!liveChildren) {
      var liveChildren = [];
      angular.forEach(indexEntry.doc.childrenIds, function (childId) {
        liveChildren.push(self.__childCollection.getItem(childId));
      });
      indexEntry.liveChildren = liveChildren;
    }
  };

  return ItemChildrenRegister;
}]);


angular.module('Relate').factory('ItemParentRegister', ["util", "$q", "BaseContainer", function(util, $q, BaseContainer) {

  var ItemParentRegister = function(db, parentCollection, childCollection, options)    {var self = this;
    var options = options || {};
    var childAlias = options.childAlias || childCollection.itemName;
    var parentAlias = options.parentAlias || parentCollection.itemName;
    self.dbDocumentType = 'lnk_parent_' + parentAlias + '_of_' + childAlias;
    self.__db = db;
    self.__index = {};
    self.__parentCollection = parentCollection;
  };
  util.inheritPrototype(ItemParentRegister, BaseContainer);
  var def = ItemParentRegister.prototype;

  def.loadDocumentFromDb = function(document)    {var self = this;
    if (self.__index[document.childId]) {
      throw "Found duplicate item parent link in database."
    }
    var newIndexEntry = {document: document};
    self.__index[document.childId] = newIndexEntry;
    return newIndexEntry;
  };
  
  def.getParent = function(childItem)    {var self = this;
    var indexEntry = self.__index[childItem._id];
    if (indexEntry) {
      if (angular.isUndefined(indexEntry.liveObject)) {
        indexEntry.liveObject = self.__parentCollection.getItem(indexEntry.document.parentId) || null;
      }
      return indexEntry.liveObject;
    }
    return null;
  };
  
  def.linkChildToParent = function(parentItem, childItem)    {var self = this;
    var deferred = $q.defer(),
        parentItemId = parentItem? parentItem._id : null,
        indexEntry = self.__index[childItem._id];
    if (indexEntry) {
      indexEntry.document.parentId = parentItemId;
      self.__db.put(indexEntry.document).then(function (result) {
        indexEntry.document._rev = result.rev;
        indexEntry.liveObject = parentItem;
        deferred.resolve();
      });
    } else {
      self.__postAndLoad({
        parentId: parentItemId, 
        childId: childItem._id
      }).then(function (result) {
        deferred.resolve();
      });      
    }
    return deferred.promise;
  };
  
  def.respondToChildDeleted = function(childItem)    {var self = this;
    var deferred = $q.defer(),
        id = childItem._id,
        indexEntry = self.__index[id];
    if (indexEntry) {
      self.__db.remove(indexEntry.document).then(function (result) {
        delete self.__index[id];
        deferred.resolve();
      });
    }
    return deferred.promise;
  };
  
  return ItemParentRegister;
}]);

    
    
/*
  Left and right may be absent from register.
  Both registers will always be equal and complimentary:
  {
     p1: {items: [t6]}
     p2: {items: [t4, t6]}
  }
  {
     t6: {items: [p1, p2]},
     t4: {items: [p2]},
  }
*/
    
angular.module('Relate').factory('ManyToManyRelationship', ["$q", "BaseContainer", "util", function($q, BaseContainer, util) {
  
  var ManyToManyRelationship = function(db, leftCollection, rightCollection, options)    {var self = this;
    var options = options || {};
    self.__rightCollection = rightCollection;
    self.__leftCollection = leftCollection;
    var defaultDbDocumentTypeName = ('lnk_' + leftCollection.itemName + '_' + rightCollection.itemName).toLowerCase();
    self.__functionNameEnd = '';
    if (options.qualifier) {
      self.__functionNameEnd = 'As' + util.capitalizeFirstLetter(options.qualifier);
      defaultDbDocumentTypeName += '_as_' + options.qualifier.toLowerCase();
    }
    self.dbDocumentType = options.dbDocumentType || defaultDbDocumentTypeName;
    self.name = self.dbDocumentType;
    self.__db = db;
    self.__leftCollection = leftCollection;
    self.__rightCollection = rightCollection;
    self.__leftRights = {};
    self.__rightLefts = {};
    self.__docsForReuse = [];
    rightCollection.registerRelationship(self);
    leftCollection.registerRelationship(self);
  };
  util.inheritPrototype(ManyToManyRelationship, BaseContainer);
  var def = ManyToManyRelationship.prototype;
  
  def.getAccessFunctionDefinitions = function()  {var self = this;
    var capitalize = util.capitalizeFirstLetter,
        buildFunc = util.createAccessFunctionDefinition,
        leftName = capitalize(self.__leftCollection.itemName),
        leftPlural = capitalize(self.__leftCollection.plural),
        rightName = capitalize(self.__rightCollection.itemName),
        rightPlural = capitalize(self.__rightCollection.plural),
        end = self.__functionNameEnd,
        getLeftRightsFnName = 'get' + leftName + rightPlural + end,
        getRightLeftsFnName = 'get' + rightName + leftPlural + end,
        addLeftRightFnName = 'add' + leftName + rightName + end,
        removeLeftRightFnName = 'remove' + leftName + rightName + end,
        isLeftLinkedToRightFnName = 'is' + leftName + 'LinkedTo' + rightName + end;
    return [
      buildFunc(getLeftRightsFnName, self.getLeftRights, false),
      buildFunc(getRightLeftsFnName, self.getRightLefts, false),
      buildFunc(addLeftRightFnName, self.addLink, true),
      buildFunc(removeLeftRightFnName, self.removeLink, true),
      buildFunc(isLeftLinkedToRightFnName, self.isLinked, false)
    ];
  };
  
  def.loadDocumentFromDb = function(doc)  {var self = this;
    if (doc.right && 
        doc.left && 
        self.__updateOneRegisterWithDocument(self.__leftRights, doc.left, doc.right, doc)
        ){
      self.__updateOneRegisterWithDocument(self.__rightLefts, doc.right, doc.left, doc);
      return true;
    } else {
      self.__sendDocumentToReusePile(doc);
      return false;
    }
  };
  
  def.__updateOneRegisterWithDocument = function(register, key, id, doc)  {var self = this;
    var entry = register[key];
    if (entry === undefined) {
      var docs = {};
      docs[id] = doc;
      register[key] = {docs: docs, items: []};
    } else {
      if (entry.docs[id]) {
        return false;
      }
      entry.docs[id] = doc;
    }
    return true;
  };
  
  def.getLeftRights = function (leftItem)  {var self = this;
    return self.__getInitialisedEntry(self.__leftRights, leftItem._id).items;
  };
  
  def.getRightLefts = function (rightItem)  {var self = this;
    return self.__getInitialisedEntry(self.__rightLefts, rightItem._id).items;
  };
  
  //TODO: assert they are of correct type?
  def.addLink = function (leftItem, rightItem)    {var self = this;
    if (self.isLinked(leftItem, rightItem)) {
      return $q.when();
    } else {
      var deferred = $q.defer();
      self.__writeLinkToDatabase(leftItem, rightItem).then(function(){
        //will have gone through loadDocumentFromDb succesfully.
        var leftEntry = self.__getInitialisedEntry(self.__leftRights, leftItem._id),
            rightEntry = self.__getInitialisedEntry(self.__rightLefts, rightItem._id);
        util.addUnique(leftEntry.items, rightItem);
        util.addUnique(rightEntry.items, leftItem);
        deferred.resolve()
      });
      return deferred.promise; 
    };
  };
  
  def.removeLink = function (leftItem, rightItem)    {var self = this;
    var leftEntry = self.__getInitialisedEntry(self.__leftRights, leftItem._id);
    var rightEntry = self.__getInitialisedEntry(self.__rightLefts, rightItem._id);
    var doc1 = self.__removeFromEntry(leftEntry, rightItem);
    var doc2 = self.__removeFromEntry(rightEntry, leftItem);
    if (doc1 !== doc2) {
      throw "This is strange..."
    }
    return self.__db.remove(doc1);
  };
  
  def.__removeFromEntry = function(entry, item)  {var self = this;
    var doc = entry.docs[item._id];
    util.removeFromArray(entry.items, item);
    delete entry.docs[item._id];
    return doc;
  }
   
  def.isLinked = function (leftItem, rightItem)  {var self = this;
    var leftEntry = self.__getInitialisedEntry(self.__leftRights, leftItem._id);
    return util.arrayContains(leftEntry.items, rightItem);
  };
  
  def.respondToItemDeleted = function (item, collection)     {var self = this;
    var opposites, itemIsFromRight;
    if (collection === self.__rightCollection) {
      itemIsFromRight = true;
      opposites = self.getRightLefts(item);
    } else if (collection === self.__leftCollection) {
      itemIsFromRight = false;
      opposites = self.getLeftRights(item);
    }
    opposites = opposites.slice();
    var operations = [];
    angular.forEach(opposites, function(oppositeItem) {
      if (itemIsFromRight) {
        var leftItem = oppositeItem;
        var rightItem = item;
      } else {
        var leftItem = item;
        var rightItem = oppositeItem;
      }
      operations.push(self.removeLink(leftItem, rightItem));
    });
    return $q.all(operations);
  };
  
  /*
  Should only be called if sure that items are not linked. Will reuse a document if one is available.
  */
  def.__writeLinkToDatabase = function(leftItem, rightItem)  {var self = this;
    var deferred = $q.defer(),
        doc = self.__docsForReuse.pop();
    function finish(succesfullyLoaded) {
      if (succesfullyLoaded) {
        deferred.resolve();
      } else {
        throw 'ManyToManyRelationship.__writeLinkToDatabase failed to load document. This should not have happened.'
      }
    }
    if (doc) {
      doc.left = leftItem._id;
      doc.right = rightItem._id;
      self.__db.put(doc).then(function (result) {
        doc._rev = result.rev;
        finish(self.loadDocumentFromDb(doc));        
      });
    } else {
      doc = {left: leftItem._id, right:rightItem._id};
      self.__postAndLoad(doc).then(function (result) {
        finish(result);
      });
    }
    return deferred.promise;
  };
  
  def.__sendDocumentToReusePile = function(doc)  {var self = this;
    self.__docsForReuse.push(doc);
  };
  
  def.__getInitialisedEntry = function (register, id)  {var self = this;
    var entry = register[id];
    if (entry === undefined) {
      entry = {docs: {}, items: []};
      register[id] = entry;
    } else {
      if (entry.items.length !== Object.keys(entry.docs).length) {
        var collection = (register === self.__leftRights)? self.__rightCollection : self.__leftCollection; 
        entry.items.length = 0;
        angular.forEach(entry.docs, function(doc, id) {
          //TODO: what if item doesn't exist?
          var item = collection.getItem(id);
          if (item) {
            entry.items.push(item);
          }
        });
      }
    }
    return entry;
  };
  
  return ManyToManyRelationship;
}]);

angular.module('Relate').service('model', ["$q", "Collection", "ParentChildRelationship", "ManyToManyRelationship", function($q, Collection, ParentChildRelationship, ManyToManyRelationship) {

  var self = this,
      __db,
      __loadQuery,
      __containers = {},
      __dbDocumentTypeLoaders = {},
      __lastPromiseInQueue = $q.when(),
      __relationshipDefinitionFunctions = {};

  self.initialize = function(db, query) {
    __db = db;
    __loadQuery = query || function() {
      return __db.allDocs({
        include_docs: true,
        attachments: false
      });
    }
  };

  var __dataReady;
  self.dataReady = function (){
    if (__dataReady === undefined) {
      __dataReady = $q.defer();
      __initializeModel().then( function () {
        __dataReady.resolve();
      });
    }
    return __dataReady.promise;
  };

  self.printInfo = function (){
    angular.forEach(__containers, function(container) {
      angular.forEach(container.getAccessFunctionDefinitions(), function(accessFunc) {
        console.log('model.' + accessFunc.ModelFunctionName);
      });
    });
  };

  /************* MODEL DEFINITION FUNCTIONS *************/

  self.collection = function(singleItemName, fieldNames, options){
    var container = new Collection(__db, singleItemName, fieldNames, options);
    __registerContainer(container);
    return container;
  };

  self.join = function(firstCollection, secondCollection, options){
    var options = options || {},
        container,
        relationshipType = options.type || 'parentChild';
    angular.forEach([firstCollection, secondCollection], function(name) {
      if (__containers[name] === undefined) {
        throw 'Failed to create join, container not found: "' + name + '" ';
      }
    });
    if (relationshipType === 'parentChild') {
      var parentCollection = __containers[firstCollection];
      var childCollection = __containers[secondCollection];
      container = new ParentChildRelationship(__db, parentCollection, childCollection, options);
    } else if (relationshipType === 'manyToMany') {
      var leftCollection = __containers[firstCollection];
      var rightCollection = __containers[secondCollection];
      container = new ManyToManyRelationship(__db, leftCollection, rightCollection, options);
    } else {
      throw '"' + relationshipType + '" is not a valid relationship type';
    }
    __registerContainer(container);
    return container;
  };

  __registerContainer = function(container) {
    var name = container.name;
    if (__containers[name] !== undefined) {
      throw 'Trying to create two containers with the same name: ' + name + ' on model but it already exists.';
    }
    __containers[name] = container;
    __registerDocumentTypeLoader(container);
    __createAccessFunctions(container);
  };

  /************* COLLECTION ACCESS FUNCTIONALITY ************

    __createAccessFunctions() creates methods like:

      model.newTask({})
      model.getProjectTasks(project)

    Query functions (getX, findX) return directly. Data changing functions (all other prefixed) return promises.

    Query data may be dirty while a promise is waiting to complete, so you need to do this:

    model.newTask({}).then(function(){
      angular.copy($scope.tasks, model.getProjectTasks($scope.project));
    });

    Data changing functions are queued internally, so you can do this.
    model.newTask({});
    model.newTask({});
    model.newTask({}).then(function(){
      angular.copy($scope.tasks, model.getProjectTasks($scope.project));
    });

  */
  self.saveItem = function(item) {
    return __containers[item.type].saveItem(item);
  };

  self.deleteItem = function(item) {
    return __containers[item.type].deleteItem(item);
  };

  function __createAccessFunctions(container){
    angular.forEach(container.getAccessFunctionDefinitions(), function(accessFunc) {
      var func, fnName = accessFunc.ModelFunctionName;
      if (accessFunc.queuedPromise) {
        func = __getQueuedFunction(container, accessFunc.containerFunction);
      } else {
        func = __getNonQueuedFunction(container, accessFunc.containerFunction);
      }
      if (self[fnName] !== undefined) {
        throw 'Container ' + container.name + ' trying to create function ' + fnName + ' on model but it already exists.';
      }
      self[fnName] = func;
    });
  };

  function __getNonQueuedFunction(container, containerFunction){
    return function() {
      return containerFunction.apply(container, arguments);
    }
  };

  function __getQueuedFunction(container, containerFunction){
    return function() {
      var originalArgs = arguments;
      var deferred = $q.defer();
      __lastPromiseInQueue.then( function() {
        __lastPromiseInQueue = containerFunction.apply(container, originalArgs);
        __lastPromiseInQueue.then(function(result) {
          deferred.resolve(result);
        });
      });
      return deferred.promise;
    }
  };

  /************* INITIAL LOADING FUNCTIONALITY *************/

  function __registerDocumentTypeLoader(container) {
    /* If container has field 'dbDocumentType' then every document whose 'type' field matches that
    will be passed to the container's loadDocumentFromDb() function at loading.
    */
    var dbDocumentType = container.dbDocumentType;
    if (dbDocumentType !== undefined) {
      if (dbDocumentType in __dbDocumentTypeLoaders) {
        var claimedBy = __dbDocumentTypeLoaders[dbDocumentType];
        throw 'More than one container attempting to register database document type: "' + dbDocumentType + '".';
      } else {
        __dbDocumentTypeLoaders[dbDocumentType] = container;
      }
    }
  };

  function __initializeModel(){
    var defer = $q.defer();
    var loadQuery = __loadQuery();
    loadQuery.then(function (result) {
      angular.forEach(result.rows, function(row){
        __addDocumentToCollection(row.doc);
      });
      __postInitialLoading();
      defer.resolve();
    }).catch(function (err) {
      console.log(err);
    });
    return defer.promise;
  };

  function __addDocumentToCollection(document){
    var dbDocumentType = document.type;
    if (dbDocumentType) {
      var container = __dbDocumentTypeLoaders[dbDocumentType];
      if (container) {
        container.loadDocumentFromDb(document, dbDocumentType);
      } else {
        console.log(document);
        console.log('Could not load document \"' + document._id + '\" as type was not recognised (' + dbDocumentType + ')');
      }
    } else {
      console.log('Could not load document \"' + document._id + '\" as it has no \"type\" field.');
    }
  };

  function __postInitialLoading() {
    angular.forEach(__containers, function(container) {
      container.postInitialLoading();
    });
  }

}]);



angular.module('Relate').factory('ParentChildRelationship', ["$q", "BaseContainer", "ValueRegister", "util", function($q, BaseContainer, ValueRegister, util) {

  var ParentChildRelationship = function(db, parentCollection, childCollection, options)    {var self = this;
    var options = options || {};
    self.__db = db;
    self.__parentCollection = parentCollection;
    self.__childCollection = childCollection;
    self.__childAlias = options.childAlias || childCollection.plural;
    self.__parentAlias = options.parentAlias || parentCollection.itemName;
    self.__parentDeleteInProgress = new ValueRegister();
    self.__cascadeDelete = (options.cascadeDelete === undefined)? true : options.cascadeDelete;
    self.__itemParent = {};
    self.__itemChildren = {};
    self.name = 'relationship_' + childCollection.itemName + '_as_' + self.__childAlias + '_' +
          parentCollection.itemName + '_as_' + self.__parentAlias;
    self.foreignKey = '__' + self.__parentAlias;
    parentCollection.registerRelationship(self);
    childCollection.registerRelationship(self, self.foreignKey);
  };
  util.inheritPrototype(ParentChildRelationship, BaseContainer);
  var def = ParentChildRelationship.prototype;

  def.getAccessFunctionDefinitions = function()  {var self = this;
    var capitalize = util.capitalizeFirstLetter,
        buildFunc = util.createAccessFunctionDefinition,
        childName = capitalize(self.__childCollection.itemName),
        childAlias = capitalize(self.__childAlias),
        parentName = capitalize(self.__parentCollection.itemName),
        parentAlias = capitalize(self.__parentAlias);
    return [
      buildFunc('get' + childName + parentAlias, self.getParent, false),
      buildFunc('get' + parentName + childAlias, self.getChildren, false),
      buildFunc('set' + childName + parentAlias, self.setChildParent, true),
    ];
  };

  def.postInitialLoading = function()  {var self = this;
    var key = self.foreignKey;
    angular.forEach(self.__parentCollection.__items, function(parentItem) {
      self.__itemChildren[parentItem._id] = [];
    });
    angular.forEach(self.__childCollection.__items, function(childItem) {
      var parentId = childItem[key];
      if (parentId) {
        var parent = self.__parentCollection.getItem(parentId);
        self.__itemParent[childItem._id] = parent;
        self.__itemChildren[parentId].push(childItem);
      }
    });
  };

  def.getParent = function (childItem)    {var self = this;
    return self.__itemParent[childItem._id] || null;
  };

  def.getChildren = function (parentItem)    {var self = this;
    return self.__itemChildren[parentItem._id] || [];
  };

  def.setChildParent = function (childItem, parentItem)    {var self = this;
    //TODO: assert they are of correct type?
    var oldParent = self.__itemParent[childItem._id];
    var parentItemId = parentItem? parentItem._id : null;
    if (oldParent) {
      util.removeFromArray(self.__itemChildren[oldParent._id], childItem);
    }
    if (parentItem) {
      if (self.__itemChildren[parentItem._id] === undefined) {
        self.__itemChildren[parentItem._id] = [childItem];
      } else {
        self.__itemChildren[parentItem._id].push(childItem);
      }
    }
    self.__itemParent[childItem._id] = parentItem;
    childItem[self.foreignKey] = parentItemId;
    return self.__childCollection.saveItem(childItem);
  };

  def.respondToItemDeleted = function (item, collection)     {var self = this;
    if (collection === self.__parentCollection) {
      return self.__respondToParentDeleted(item);
    } else if (collection === self.__childCollection) {
      return self.__respondToChildDeleted(item);
    }
  };

  def.__respondToParentDeleted = function (parentItem)     {var self = this;
    var action = (self.__cascadeDelete)?
        function(childItem) {return self.__childCollection.deleteItem(childItem)} :
        function(childItem) {return self.setChildParent(childItem, null)};
    var children = self.getChildren(parentItem).slice(); //slice() is imortant!
    return $q.all(children.map(action)).then(function() {
      delete self.__itemChildren[parentItem._id];
      return $q.when(true);
    }, util.promiseFailed);
  };

  def.__respondToChildDeleted = function (childItem)     {var self = this;
    var parentItem = self.getParent(childItem);
    if (parentItem) {
      util.removeFromArray(self.__itemChildren[parentItem._id], childItem);
    }
    delete self.__itemParent[childItem._id];
    return $q.when(true);
  };

  return ParentChildRelationship;
}]);


angular.module('Relate').factory('QueuedResponseDb', ["$q", "ValueRegister", function($q, ValueRegister) {
  /*
  post put get remove
  */
  var QueuedResponseDb = function(db) {
    var self = this;
    self._db = db;
    self.queue = {};
    self._nextId = 0;
    self._latestResolvedId = 1;
    
    self.wrapPromise = function(dbCall, data) {
      var promiseId = self.nextId();
      var hiddenPromise = self._db[dbCall](data);
      var returnPromise = $q.defer();
      self.queuePromise(promiseId, returnPromise);
      hiddenPromise.then(function(response) {
        self.promiseGotResolved(promiseId, response);
      });
      return returnPromise.promise;
    };
    angular.forEach(['post', 'put', 'get', 'remove'], function (dbCall) {
      self[dbCall] = function(data) {
        return self.wrapPromise(dbCall, data);
      }
    });
  };
  
  QueuedResponseDb.prototype.nextId = function (){
    this._nextId ++;
    return this._nextId;
  }
  
  QueuedResponseDb.prototype.queuePromise = function(promiseId, returnPromise) {
    this.queue[promiseId] = {
      returnPromise: returnPromise,
      resolved: false
    };
  };
  
  QueuedResponseDb.prototype.promiseGotResolved = function(promiseId, result) {
    var promise = this.queue[promiseId]
    promise['result'] = result;
    promise.resolved = true;
    this.releasResolvedPromises();
  };
  
  QueuedResponseDb.prototype.releasResolvedPromises = function() {
    var stop = false; // encounteredUnresolvedPromiseOrReachedEndOfQueue
    while (!stop) {
      entry = this.queue[this._latestResolvedId]
      if (entry && entry.resolved) {
        entry.returnPromise.resolve(entry.result);
        this._latestResolvedId ++;
      } else {
        stop = true;
      }
    }
  }
  
  return QueuedResponseDb;
}]);
/*
New way:

Specify one relationship per collection.
It knows of the other collection, and how the relationship behaves.

The model is responisble for passing complementary relationships to the collections.

Linking:
   collection ends up with methods:
   setParent
   addChild
   removeChild
   addTag
   removeTag
   
  model.join({type: 'parentChild'... })
    r1 = parentChildRelationship(parent, child)
    r2 = childParentRelationship(parent, child)
    parentCollection.registerRelationship(r1)
    parentCollection.registerRelationship(r2)
    childCollection.registerRelationship(r1)
    childCollection.registerRelationship(r2)
  }
  What does a relationship do:
    create accessor functions (get, set)
    respond to deletions
    respond to new
    
    
  Deletions:
    if has child items: 
      delete:
        chilren
        parent of child links 
        children of parent
    if has parent items:
      delete:
        parent of child links 
        children of parent
    if many to many:
      delete join only
      
    ...but parent child deletions could benefit from not having all the items stripped first. Do I care?
    I could collate operations on the db side (i.e. collect changes to single objects, and flush them after a period)
    
    
      
*/

angular.module('Relate').factory('ParentRelationshipNew', ["$q", function($q) {

  var Relationship = function(propertyName, parentCollection, parentPopertyName) {
    this.propertyName = propertyName;
    this._parentCollection = parentCollection;
    this._parentPopertyName = parentPopertyName;
  };
  
  Relationship.prototype._convertFromDoc = function(doc) {
    var value = doc[this.propertyName];
    if (value) {
      this._parentCollection.getItem(value);
    }
  };
  
  Relationship.prototype._convertToDoc = function(value) {
    return value.id;
  };
  
  Relationship.prototype._onItemRemove = function(item) {
    var value = doc[this.propertyName];
    if (value) {
      var parentItem = this._parentCollection.getItem(value);
      if (parentItem) {
        parentItem._links[this._parentPopertyName]
      }
    }
  };
  
}]);



angular.module('Relate').service('util', ["$q", function($q) {
  var self = this;

  self.capitalizeFirstLetter = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };

  self.createAccessFunctionDefinition = function(name, fn, queuedPromise) {
    return {
      ModelFunctionName: name,
      containerFunction: fn,
      queuedPromise: queuedPromise
    }
  };

  self.arrayContains = function(myArray, item) {
    for (var i = 0, len = myArray.length; i < len; i++) {
      if (item === myArray[i]) {
        return true;
      }
    }
    return false;
  };

  self.addUnique = function(myArray, item) {
    if(!self.arrayContains(myArray, item)){
      myArray.push(item);
    }
  }

  self.addAsItem = function(object, key, item) {
    //Where object[key] = [items...]
    if (object[key] === undefined) {
      object[key] = [item];
    } else {
      object[key].push(item);
    }
  };

  self.removeFromArray = function(myArray, item) {
    var index = myArray.indexOf(item);
    if (index > -1) {
      myArray.splice(index, 1);
    }
  };

  self.filterIndex = function(index, test) {
    //accepts an object like array.
    var filteredItems = [];
    angular.forEach(index, function(item) {
      if (test(item)) {
        filteredItems.push(item);
      }
    });
    return filteredItems;
  };

  self.inheritPrototype = function(Child, Parent) {
    var childProto = Child.prototype;
    var parentProto = Parent.prototype;
    for (var prop in parentProto) {
      if (typeof parentProto[prop] == 'function') {
        childProto[prop] = parentProto[prop];
      }
    }
  };

  self.copyFields = function(source, target, fields) {
    angular.forEach(fields, function(field) {
      target[field] = source[field];
    });
  };

  self.promiseFailed = function(error) {
    console.log('Promise failed!');
    console.log(error);
  }

}]);


angular.module('Relate').factory('ValueRegister', function() {
  //
  var ValueRegister = function() {
    this._register = {};
  };
  ValueRegister.prototype.set = function(key, value) {
    this._register[key] = value;
  };
  ValueRegister.prototype.get = function(key) {
    return this._register[key];
  };
  
  return ValueRegister;
});
