[npm-url]: https://npmjs/package/sneakerjs
[npm-version-image]: https://badge.fury.io/js/sneakerjs.svg
[npm-downloads-image]: https://img.shields.io/npm/dt/sneakerjs.svg
[travis-image]: https://img.shields.io/travis/andyhasit/SneakerJS.svg
[travis-url]: https://travis-ci.org/andyhasit/SneakerJS
[coveralls-image]: https://img.shields.io/coveralls/andyhasit/SneakerJS.svg
[coveralls-url]: https://coveralls.io/github/andyhasit/SneakerJS

<p align="center">
<img src="logo.gif" width="250">
</p>

## SneakerJS
Entity relationship magic for AngularJS and PouchDB.

[![npm version][npm-version-image]][npm-url]
[![npm downloads][npm-downloads-image]][npm-url]
[![Build Status][travis-image]][travis-url]

## What does it do?

Well it's simple, you just:

* Create a local PouchDB database
* Define your model (collections + relationships) using Sneaker's simple API.

SneakerJS will then:

* Load the collections in memory and _bi-directionally_ map the relationships for super fast querying.
* Generate intelligently named functions to work with your collections and relationships.

What this means is:

* You can write concise, readable code using your domain language.
* You can query collections and relationships directly in your views (no need for services or controllers) and it will all be lightening fast.
* Changes will be automatically saved to your local database (and optionally synchronized with a remote CouchDB) and will update your views without you having to call __\$digest()__ or __\$apply()__ and this will be lightening fast too.


* You have just saved yourself a lot of boilerplate code to achieve the same result.

To understand the full awesomness, and how much typing this saves you, it is best to study a small example. 

### A Small Example

Consider a blog platform with __posts__, __comments__, and __tags__. All you need to do is:

- Create the PouchDB
- Define our collections (__posts__, __comments__, and __tags__) and fields
- Define the relationships between the collections
- Save your model as __db__ on __$rootScope__ (optional, just for convenience)

```javascript
var app = angular.module('app', ['SneakerJS']);
app.run(function(SneakerModel, $rootScope) {
  var database = new PouchDB('my_local_database');
  var db = new SneakerModel(database);
  db.collection('post', ['title', 'datetime', 'text']);
  db.collection('comment', ['datetime', 'text']);
  db.collection('tag', ['name']);
  db.oneToMany('post', 'comment');
  db.manyToMany('post', 'tag');
  db.dataReady().then(function() {
    $rootScope.db = db;
  });
});
```

You can then write template code using the __intelligently generated__ functions: 

```html
<div ng-app="app">
  <div ng-repeat="post in db.allPosts()">
    <h3>{{post.title}}</h3>
    This post has {{db.getPostComments(post).length}} comments.<br/>
    <h5>Tags:</h5>
    <span ng-repeat="tag in db.getPostTags(post)">{{tag.name}}</span>
  </div>
</div>
```

A few notes:

* The functions __allPosts()__, __getPostComments()__ and __getPostTags()__ were all generated by SneakerJS according to the names of your collections (but you can override these).
* Query functions return actual objects and arrays, not promises (otherwise this code would not be possible).
* These queries are super fast, as each parent-child relationship is cached bi-directionally in memory (in deeply nested cases this can be over 100x faster than map-reduce!)
* Did you notice we didn't even need a _controller_ or _service_ for this page?
* SneakerJS will also generate __newPost()__, __addPostTag()__, __removePostTag()__ etc... (note: functions which modify data return promises)
* Because it's [PouchDB](https://pouchdb.com/), you can synchronise your local db with a remote CouchDB with a single line of code.
* Passing a mock [PouchDB](https://pouchdb.com/) object to route calls to your API instead of the local database is trivial.
* You can specify a prototype object for a collection (every item will get instantiated to it) allowing for powerful behaviour.
* If you do `SneakerModel.call(this, database)` inside a service instead of in `app.run()` then the generated functions will be attached to that service, which some might prefer.
* You can override the generated functions (e.g. you might want __newPost()__ to do some additional stuff)
* You can define various relationships like one-to-many, many-to-many (without having to create an intermediate collection) and also singleton objects instead of collections (e.g. for user settings)
* You can have multiple relationships between the same two collections using different qualifiers, e.g. __setPostUserAsAuthor()__ and __setPostUserAsReviewer()__.

## Demo

Here is a simple [Plunkr](https://embed.plnkr.co/KY2pgdSpg3KWxQrWQhSC/). 
There is also a [demo project](demos/demo_1) included.

## Installation

```shell
npm install sneakerjs --save
```

## User Guide

Yes, there is a complete [User Guide](User Guide.md)!


## Reporting bugs

Please report any issues in the [issue tracker](https://github.com/andyhasit/SneakerJS/issues).

## Running test

Tests are written in Jasmine, run with Karma, and code coverage checked with Istanbul.

    npm test

Tests currently use [karma-nicer-reporter](https://github.com/andyhasit/karma-nicer-reporter).

## Licence

[MIT](https://opensource.org/licenses/MIT)

